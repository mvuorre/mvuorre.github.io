{
  "hash": "32f054f279690ea3d2cd948cb3e96bd0",
  "result": {
    "markdown": "---\ntitle: Bayes Factors with brms\ndescription: |\n  How to calculate Bayes Factors with the R package brms using the Savage-Dickey density ratio method.\ndate: 2017-03-21\ncategories:\n  - statistics\n  - tutorial\n  - R\n  - brms\nbibliography: bibliography.bib\nimage: \"index_files/figure-html/figure1-1.png\"\n---\n\n\n\n\n\n\nHere's a short post on how to calculate Bayes Factors with the R package [brms](http://CRAN.R-project.org/package=brms) using the Savage-Dickey density ratio method [@wagenmakers_bayesian_2010]. \n\nTo get up to speed with what the Savage-Dickey density ratio method is--or what Bayes Factors are--please read the target article [@wagenmakers_bayesian_2010]. (The paper is available on the [author's webpage](http://www.ejwagenmakers.com/2010/WagenmakersEtAlCogPsy2010.pdf).) Here, I'll only show the R & brms code to do the calculations discussed in @wagenmakers_bayesian_2010. In their paper, they used WinBUGS, which requires quite a bit of code to sample from even a relatively simple model. brms on the other hand uses the familiar R formula syntax, making it easy to use. brms also does the MCMC sampling with [Stan](http://mc-stan.org/) [@stan_development_team_stan:_2016], or rather creates Stan code from a specified R model formula by what can only be described as string processing magic, making the sampling very fast. Let's get straight to the examples. We will use these packages:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/packages_50922088949ccc77b1646107a2c1b79c'}\n\n```{.r .cell-code}\nlibrary(knitr)\nlibrary(kableExtra)\nlibrary(scales)\nlibrary(brms)\nlibrary(patchwork)\nlibrary(tidyverse)\n```\n:::\n\n\n## Example 0\n\nWagenmakers and colleagues begin with a simple example of 10 true/false questions: We observe a person answering 9 (s) out of 10 (k) questions correctly.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-1_cc51a5e32633ed7a27a3f660e91e1efd'}\n\n```{.r .cell-code}\nd <- data.frame(s = 9, k = 10)\n```\n:::\n\n\nWe are interested in the person's latent ability to answer similar questions correctly. This ability is represented by $\\theta$ (theta), which for us will be the probability parameter (sometimes also called the rate parameter) in a binomial distribution. The maximum likelihood (point) estimate for $\\theta$ is the proportion n/k = .9.\n\nThe first thing we'll need to specify with respect to our statistical model is the prior probability distribution for $\\theta$. As in Wagenmakers et al. 2010, we specify a uniform prior, representing no prior information about the person's ability to aswer the questions. For the binomial probability parameter, $Beta(\\alpha = 1, \\beta = 1)$ is a uniform prior.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-2_8bab6d1522df9f9ac544afd66105aa74'}\n\n```{.r .cell-code}\npd <- tibble(\n  x = seq(0, 1, by = .01),\n  Prior = dbeta(x, 1, 1)\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThe solid line represents the probability density assigned to values of $\\theta$ by this prior probability distribution. You can see that it is 1 for all possible parameter values: They are all equally likely a priori. For this simple illustration, we can easily calculate the posterior distribution by adding the number of correct and incorrect answers to the parameters of the prior Beta distribution.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/figure1_3dc4bd868858cf18fe8fa3481b566395'}\n\n```{.r .cell-code}\npd$Posterior <- dbeta(pd$x, 9+1, 1+1)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/figure1-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nThe Savage-Dickey density ratio is calculated by dividing the posterior density by the prior density at a specific parameter value. Here, we are interested in .5, a \"null hypothesis\" value indicating that the person's latent ability is .5, i.e. that they are simply guessing. \n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-3_fb1e118b34bd94a7e42c6bdde6483200'}\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Bayes Factors for first example.</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:right;\"> x </th>\n   <th style=\"text-align:right;\"> Prior </th>\n   <th style=\"text-align:right;\"> Posterior </th>\n   <th style=\"text-align:right;\"> BF01 </th>\n   <th style=\"text-align:right;\"> BF10 </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:right;\"> 0.5 </td>\n   <td style=\"text-align:right;\"> 1 </td>\n   <td style=\"text-align:right;\"> 0.107 </td>\n   <td style=\"text-align:right;\"> 0.107 </td>\n   <td style=\"text-align:right;\"> 9.309 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n:::\n\n\nOK, so in this example we are able to get to the posterior with simply adding values into the parameters of the Beta distribution, but let's now see how to get to this problem using brms. First, here's the brms formula of the model:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-4_f71290f001916c2673434922a43172c7'}\n\n```{.r .cell-code}\nm0 <- bf(\n  s | trials(k) ~ 0 + Intercept,\n  family = binomial(link = \"identity\")\n)\n```\n:::\n\n\nRead the first line as \"s successes from k trials regressed on intercept\". That's a little clunky, but bear with it. If you are familiar with R's modeling syntax, you'll be wondering why we didn't simply specify `~ 1` (R's default notation for an intercept). The reason is that brms by default uses a little trick in parameterizing the intercept which speeds up the MCMC sampling. In order to specify a prior for the intercept, you'll have to take the default intercept out (`0 +`), and use the reserved string `intercept` to say that you mean the regular intercept. See `?brmsformula` for details. (For this model, with only one parameter, this complication doesn't matter, but I wanted to introduce it early on so that you'd be aware of it when estimating multi-parameter models.)\n\nThe next line specifies that the data model is binomial, and that we want to model it's parameter through an identity link. Usually when you model proportions or binary data, you'd use a logistic (logistic regression!), probit or other similar link function. In fact this is what we'll do for later examples. Finally, we'll use the data frame `d`.\n\nOK, then we'll want to specify our priors. Priors are extremo important for Bayes Factors--and probabilistic inference in general. To help set priors, we'll first call `get_priors()` with the model information, which is basically like asking brms to tell what are the possible priors, and how to specify then, given this model.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-5_c86354cd23443caadb4f8ed21559cfb9'}\n\n```{.r .cell-code}\nget_prior(m0, data = d)\n##   prior class      coef group resp dpar nlpar lb ub       source\n##  (flat)     b                                            default\n##  (flat)     b Intercept                             (vectorized)\n```\n:::\n\n\nThe first line says that there is only one class of parameters `b`, think of class `b` as \"betas\" or \"regression coefficients\". The second line says that the `b` class has only one parameter, the intercept. So we can set a prior for the intercept, and this prior can be any probability distribution in Stan language. We'll create this prior using brms' `set_prior()`, give it a text string representing the Beta(1, 1) prior for all parameters of class `b` (shortcut, could also specify that we want it for the intercept specifically), and then say the upper and lower bounds ($\\theta$ must be between 0 and 1).\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-6_3fb335effddea5621cb4e2f1865d045c'}\n\n```{.r .cell-code}\nPrior <- set_prior(\"beta(1, 1)\", class = \"b\", lb = 0, ub = 1)\n```\n:::\n\n\nAlmost there. Now we'll actually sample from the model using `brm()`, give it the model, priors, data, ask it to sample from priors (for the density ratio), and set a few extra MCMC parameters.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-7_284135aafe8234ebf5596ac8a6a2e6d3'}\n\n```{.r .cell-code}\nm <- brm(\n  formula = m0,\n  prior = Prior,\n  data = d,\n  sample_prior = TRUE,\n  iter = 1e4,\n  cores = 4,\n  file = \"bayesfactormodel\"\n)\n```\n:::\n\n\nWe can get the estimated parameter by asking the model summary:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-8_6c850acdbbc4945d8d9f15801f02e895'}\n\n```{.r .cell-code}\nsummary(m)\n##  Family: binomial \n##   Links: mu = identity \n## Formula: s | trials(k) ~ 0 + Intercept \n##    Data: d (Number of observations: 1) \n##   Draws: 4 chains, each with iter = 10000; warmup = 5000; thin = 1;\n##          total post-warmup draws = 20000\n## \n## Population-Level Effects: \n##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## Intercept     0.83      0.10     0.59     0.98 1.00     6331     6217\n## \n## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\n## and Tail_ESS are effective sample size measures, and Rhat is the potential\n## scale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n\n\nThe Credible Interval matches exactly what's reported in the paper. The point estimate differs slightly because here we see the posterior mean, whereas in the paper, Wagenmakers et al. report the posterior mode. I'll draw a line at their posterior mode, below, to show that it matches.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-9_0579405a8f362975d9015e6982268847'}\n\n```{.r .cell-code}\nsamples <- posterior_samples(m, \"b\")\n```\n\n::: {.cell-output-display}\n`````{=html}\n<table class=\"table\" style=\"width: auto !important; margin-left: auto; margin-right: auto;\">\n<caption>Six first rows of posterior samples.</caption>\n <thead>\n  <tr>\n   <th style=\"text-align:right;\"> b_Intercept </th>\n   <th style=\"text-align:right;\"> prior_b </th>\n  </tr>\n </thead>\n<tbody>\n  <tr>\n   <td style=\"text-align:right;\"> 0.85 </td>\n   <td style=\"text-align:right;\"> 0.41 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 0.68 </td>\n   <td style=\"text-align:right;\"> 0.23 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 0.73 </td>\n   <td style=\"text-align:right;\"> 0.95 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 0.78 </td>\n   <td style=\"text-align:right;\"> 0.60 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 0.78 </td>\n   <td style=\"text-align:right;\"> 0.25 </td>\n  </tr>\n  <tr>\n   <td style=\"text-align:right;\"> 0.81 </td>\n   <td style=\"text-align:right;\"> 0.88 </td>\n  </tr>\n</tbody>\n</table>\n\n`````\n:::\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nWe can already see the densities, so all that's left is to obtain the exact values at the value of interest (.5) and take the $\\frac{posterior}{prior}$ ratio. Instead of doing any of this by hand, we'll use brms' function `hypothesis()` that allows us to test point hypotheses using the Dickey Savage density ratio. For this function we'll need to specify the point of interest, .5, as the point hypothesis to be tested.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-10_e7d6d29f2b2925eb91836ac3b9071797'}\n\n```{.r .cell-code}\nh <- hypothesis(m, \"Intercept = 0.5\")\nprint(h, digits = 4)\n## Hypothesis Tests for class b:\n##              Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio Post.Prob Star\n## 1 (Intercept)-(0.5) = 0    0.335    0.1037   0.0892   0.4781     0.1119    0.1006    *\n## ---\n## 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses.\n## '*': For one-sided hypotheses, the posterior probability exceeds 95%;\n## for two-sided hypotheses, the value tested against lies outside the 95%-CI.\n## Posterior probabilities of point hypotheses assume equal prior probabilities.\n```\n:::\n\n\nThe `Evid.Ratio` is our Bayes Factor BF01. Notice that it matches the value 0.107 pretty well. You can also plot this hypothesis object easily with the `plot()` method:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-11_03064fc0db1b62e777eec8594f967597'}\n\n```{.r .cell-code}\nplot(h)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nOK, so that was a lot of work for such a simple problem, but the real beauty of brms (and Stan) is the scalability: We can easily solve a problem with one row of data and one parameter, and it won't take much more to solve a problem with tens of thousands of rows of data, and hundreds of parameters. Let's move on to the next example from @wagenmakers_bayesian_2010.\n\n## Example 1: Equality of Proportions\n\nThese are the data from the paper \n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-12_2bbf7d86300289ec68bc33f532937fbf'}\n\n```{.r .cell-code}\nd <- data.frame(\n  pledge = c(\"yes\", \"no\"),\n  s = c(424, 5416),\n  n = c(777, 9072)\n)\nd\n##   pledge    s    n\n## 1    yes  424  777\n## 2     no 5416 9072\n```\n:::\n\n\nThey use Beta(1, 1) priors for both rate parameters, which we'll do as well. Notice that usually a regression formula has an intercept and a coefficient (e.g. effect of group.) By taking the intercept out (`0 +`) we can define two pledger-group proportions instead, and set priors on these. If we used an intercept + effect formula, we could set a prior on the effect itself.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-13_90d12253ac90d1f3b47323ad5fa115c0'}\n\n```{.r .cell-code}\nm1 <- bf(\n  s | trials(n) ~ 0 + pledge,\n  family = binomial(link = \"identity\")\n)\nget_prior(\n  m1,\n  data = d\n)\n##   prior class      coef group resp dpar nlpar lb ub       source\n##  (flat)     b                                            default\n##  (flat)     b  pledgeno                             (vectorized)\n##  (flat)     b pledgeyes                             (vectorized)\n```\n:::\n\n\nWe can set the Beta prior for both groups' rate with one line of code by setting the prior on the `b` class without specifying the `coef`. \n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-14_85decd0258db5c981f4bf36b61c6d999'}\n\n```{.r .cell-code}\nPrior <- set_prior(\"beta(1, 1)\", class = \"b\", lb = 0, ub = 1)\n```\n:::\n\n\nLike above, let's estimate.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-15_939f9fe59972232a3315322c9bc988d0'}\n\n```{.r .cell-code}\nm1 <- brm(\n  m1,\n  prior = Prior,\n  sample_prior = TRUE,\n  iter = 1e4,\n  data = d,\n  cores = 4,\n  file = \"bayesfactormodel2\"\n)\n```\n:::\n\n\nOur estimates match the MLEs reported in the paper:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-16_1fda04a0f242dafa295451c3f39be1a4'}\n\n```{.r .cell-code}\nsummary(m1)\n##  Family: binomial \n##   Links: mu = identity \n## Formula: s | trials(n) ~ 0 + pledge \n##    Data: d (Number of observations: 2) \n##   Draws: 4 chains, each with iter = 10000; warmup = 5000; thin = 1;\n##          total post-warmup draws = 20000\n## \n## Population-Level Effects: \n##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## pledgeno      0.60      0.01     0.59     0.61 1.00    17582    12872\n## pledgeyes     0.55      0.02     0.51     0.58 1.00    19471    13744\n## \n## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\n## and Tail_ESS are effective sample size measures, and Rhat is the potential\n## scale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n\n\nTo get the density ratio Bayes Factor, we'll need to specify a text string as our hypothesis. Our hypothesis is that the rate parameters $\\theta_1$ and $\\theta_2$ are not different: $\\theta_1$ = $\\theta_2$. The alternative, then, is the notion that the parameter values differ.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-17_f3941cb242db1c037d29915016d4e7ad'}\n\n```{.r .cell-code}\nh1 <- hypothesis(m1, \"pledgeyes = pledgeno\")\nh1\n## Hypothesis Tests for class b:\n##                 Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio Post.Prob Star\n## 1 (pledgeyes)-(pled... = 0    -0.05      0.02    -0.09    -0.02       0.55      0.36    *\n## ---\n## 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses.\n## '*': For one-sided hypotheses, the posterior probability exceeds 95%;\n## for two-sided hypotheses, the value tested against lies outside the 95%-CI.\n## Posterior probabilities of point hypotheses assume equal prior probabilities.\n```\n:::\n\n\nAs noted in the paper, a difference value of 0 is about twice as well supported before seeing the data, i.e. the null hypothesis of no difference is twice less likely after seeing the data:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-18_ead8dac40605294695c217abdc41dba0'}\n\n```{.r .cell-code}\n1 / h1$hypothesis$Evid.Ratio # BF10\n## [1] 1.808643\n```\n:::\n\n\nThe paper reports BF01 = 0.47, so we're getting the same results (as we should.) You can also compare this figure to what's reported in the paper.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-19_fe9d6c85bf18b295d23dd39713de79c2'}\n\n```{.r .cell-code}\nh1p1 <- plot(h1, plot = F)[[1]]\nh1p2 <- plot(h1, plot = F)[[1]] +\n  coord_cartesian(xlim = c(-.05, .05), ylim = c(0, 5))\n  \n(h1p1 | h1p2) +\n  plot_layout(guides = \"collect\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-19-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nMoving right on to Example 2, skipping the section on \"order restricted analysis\".\n\n## Example 2: Hierarchical Bayesian one-sample proportion test\n\nThe data for example 2 is not available, but we'll simulate similar data. The simulation assumes that the neither-primed condition average correct probability is 50%, and that the both-primed condition benefit is 5%. Obviously, the numbers here won't match anymore, but the data reported in the paper has an average difference in proportions of about 4%.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-20_f3fee0a30f209fdea026ce047ba0e748'}\n\n```{.r .cell-code}\nset.seed(5)\nd <- tibble(\n  id = c(rep(1:74, each = 2)),\n  primed = rep(c(\"neither\", \"both\"), times = 74),\n  prime = rep(c(0, 1), times = 74), # Dummy coded\n  n = 21,\n  correct = rbinom(74 * 2, 21, .5 + prime * .05)\n)\ngroup_by(d, primed) %>% summarize(p = sum(correct) / sum(n))\n## # A tibble: 2 Ã— 2\n##   primed      p\n##   <chr>   <dbl>\n## 1 both    0.542\n## 2 neither 0.499\n```\n:::\n\n\nThis data yields a similar t-value as in the paper.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-21_7cbf84f49d65b19f5829d7e24b4ed4a3'}\n\n```{.r .cell-code}\nt.test(correct / n ~ primed, paired = T, data = d)\n## \n## \tPaired t-test\n## \n## data:  correct/n by primed\n## t = 2.3045, df = 73, p-value = 0.02404\n## alternative hypothesis: true difference in means is not equal to 0\n## 95 percent confidence interval:\n##  0.005741069 0.079201016\n## sample estimates:\n## mean of the differences \n##              0.04247104\n```\n:::\n\n\nInstead of doing a probit regression, I'm going to do logistic regression. Therefore we define the prior on the log-odds scale. The log odds for the expected probability of .5 is 0. I prefer log-odds because--although complicated--they make sense, unlike standardized effect sizes. Note that the probit scale would also be fine as they are very similar.\n\nLet's just get a quick intuition about effects in log-odds: The change in log odds from p = .5 to .55 is about 0.2.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-22_4334c2ea6cc77cc282384accbf85d0ea'}\n\n```{.r .cell-code}\ntibble(\n  rate = seq(0, 1, by = .01),\n  logit = arm::logit(rate)\n) %>%\n  ggplot(aes(rate, logit)) +\n  geom_line(size = 1) +\n  geom_segment(x = 0, xend = 0.55, y = .2, yend = .2, size = .4) +\n  geom_segment(x = 0, xend = 0.5, y = 0, yend = 0, size = .4) +\n  coord_cartesian(ylim = c(-2, 2), expand = 0)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-22-1.png){fig-align='center' width=672}\n:::\n:::\n\n\nWe are cheating a little because we know these values, having simulated the data. However, log-odds are not straightforward (!), and this knowledge will allow us to specify better priors in this example. Let's get the possible priors for this model by calling `get_prior()`. Notice that the model now includes id-varying \"random\" effects, and we model them from independent Gaussians by specifying `||` instead of `|` which would give a multivariate Gaussian on the varying effects.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-23_9b08ef9a3926e03c3b96fbc107b7f821'}\n\n```{.r .cell-code}\nm2 <- bf(\n  correct | trials(n) ~ 0 + Intercept + prime +\n    (0 + Intercept + prime || id),\n  family = binomial(link = \"logit\")\n)\nget_prior(\n  m2,\n  data = d\n)\n##                 prior class      coef group resp dpar nlpar lb ub       source\n##                (flat)     b                                            default\n##                (flat)     b Intercept                             (vectorized)\n##                (flat)     b     prime                             (vectorized)\n##  student_t(3, 0, 2.5)    sd                                  0         default\n##  student_t(3, 0, 2.5)    sd              id                  0    (vectorized)\n##  student_t(3, 0, 2.5)    sd Intercept    id                  0    (vectorized)\n##  student_t(3, 0, 2.5)    sd     prime    id                  0    (vectorized)\n```\n:::\n\n\nThe leftmost column gives the pre-specified defaults used by brms. Here are the priors we'll specify. The most important pertains to `prime`, which is going to be the effect size in log-odds. Our prior for the log odds of the prime effect is going to be a Gaussian distribution centered on 0, with a standard deviation of .2, which is rather diffuse.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-24_30f40e13ceb271f8eeebda753a8e58c4'}\n\n```{.r .cell-code}\nPrior <- c(\n  set_prior(\"normal(0, 10)\", class = \"b\", coef = \"Intercept\"),\n  set_prior(\"cauchy(0, 10)\", class = \"sd\"),\n  set_prior(\"normal(0, .2)\", class = \"b\", coef = \"prime\")\n)\n```\n:::\n\n\nThen we estimate the model using the specified priors.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-25_100bf6f068f10b1720bd39145f877cd9'}\n\n```{.r .cell-code}\nm2 <- brm(\n  m2,\n  prior = Prior,\n  sample_prior = TRUE,\n  iter = 1e4,\n  data = d,\n  cores = 4,\n  file = \"bayesfactormodel3\"\n)\n```\n:::\n\n\nOK, so our results here will be different because we didn't parameterize the prior on a standardized effect size because **a**) I don't like standardized effect sizes, and **b**) I would have to play around with the Stan code, and this post is about brms. Anyway, here are the estimated parameters:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-26_2121e3c1317d461ed846d6376ac78d19'}\n\n```{.r .cell-code}\nsummary(m2)\n##  Family: binomial \n##   Links: mu = logit \n## Formula: correct | trials(n) ~ 0 + Intercept + prime + (0 + Intercept + prime || id) \n##    Data: d (Number of observations: 148) \n##   Draws: 4 chains, each with iter = 10000; warmup = 5000; thin = 1;\n##          total post-warmup draws = 20000\n## \n## Group-Level Effects: \n## ~id (Number of levels: 74) \n##               Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## sd(Intercept)     0.07      0.05     0.00     0.18 1.00     6289     7595\n## sd(prime)         0.12      0.08     0.01     0.30 1.00     5325     7048\n## \n## Population-Level Effects: \n##           Estimate Est.Error l-95% CI u-95% CI Rhat Bulk_ESS Tail_ESS\n## Intercept     0.01      0.05    -0.09     0.11 1.00    15752    13860\n## prime         0.15      0.07     0.01     0.29 1.00    14810    14424\n## \n## Draws were sampled using sampling(NUTS). For each parameter, Bulk_ESS\n## and Tail_ESS are effective sample size measures, and Rhat is the potential\n## scale reduction factor on split chains (at convergence, Rhat = 1).\n```\n:::\n\n\nAnd our null-hypothesis density ratio:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-27_caf739a0b00834b17c2c7fef7deb118d'}\n\n```{.r .cell-code}\nh2 <- hypothesis(m2, \"prime = 0\")\nh2\n## Hypothesis Tests for class b:\n##    Hypothesis Estimate Est.Error CI.Lower CI.Upper Evid.Ratio Post.Prob Star\n## 1 (prime) = 0     0.15      0.07     0.01     0.29       0.31      0.23    *\n## ---\n## 'CI': 90%-CI for one-sided and 95%-CI for two-sided hypotheses.\n## '*': For one-sided hypotheses, the posterior probability exceeds 95%;\n## for two-sided hypotheses, the value tested against lies outside the 95%-CI.\n## Posterior probabilities of point hypotheses assume equal prior probabilities.\n```\n:::\n\n\nPriming effect of zero log-odds is 4 times less likely after seeing the data:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-28_10dd8c444e34a93c2734fec2400567cd'}\n\n```{.r .cell-code}\n1 / h2$hypothesis$Evid.Ratio\n## [1] 3.267158\n```\n:::\n\n\nThis is best illustrated by plotting the densities:\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/html/unnamed-chunk-29_8bdb9fb111bdedf9ec600ab4a1bb4fc3'}\n\n```{.r .cell-code}\nplot(h2)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-29-1.png){fig-align='center' width=672}\n:::\n:::\n\n\n## Conclusion\n\nRead the paper! Hopefully you'll be able to use brms' `hypothesis()` function to calculate bayes factors when needed.\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/kePrint-0.0.1/kePrint.js\"></script>\n<link href=\"../../site_libs/lightable-0.0.1/lightable.css\" rel=\"stylesheet\" />\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}